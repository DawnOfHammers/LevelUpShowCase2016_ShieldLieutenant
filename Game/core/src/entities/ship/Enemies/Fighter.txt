package entities.ship.Enemies;

import com.badlogic.gdx.scenes.scene2d.Actor;
import entities.projectiles.Bullet;
import gamestates.playState.GameStage;

import java.util.ArrayList;

/**
 * Created by Feng on 12/29/2015.
 */
public class Fighter extends Enemy {
    /**Creates a new Fighter at points x,y.
     *
     * @param x X - Cord
     * @param y Y - Cord
     */
    private double tg_angle;
    private int turnrate;
    private int cooldown;
    public Fighter(int x, int y, GameStage gs){
        super(x,y,"Proto.png", gs);
        super.health = 5;
        super.speed = 3;
        super.range = 250;

        super.actions = new boolean[4];

	this.tg_angle = super.angle;
        this.turnrate = 3;
        this.cooldown = 0;
    }

    /**
     * Action 0: [Fire].
     *           - In range.
     *           - Shots Lined Up.
     *           - Weapon reloaded.
     *
     * Action 1: [Coming].
     *
     * Action 2: [Going].
     *
     * Action 3: [Moving].
     */
    @Override
    protected void aiPlan(){
        ArrayList<Actor> actors = gamestage.getActorList();

        boolean inrange = range * range > Math.pow(actors.get(0).getX() - this.getX(), 2)
                                        + Math.pow(actors.get(0).getY() - this.getY(), 2);
	
        actions[0] = inrange && angle == tg_angle && cooldown == 0;
        actions[1] = cooldown == 0;		   
        actions[2] = cooldown != 0;
	actions[3] = health > 2;
    }

    /**Action 0: 
     *
     * Action 1: 
     *
     * Action 2: 
     * 
     * Action 3: 
     */
    @Override
    protected void aiAct(){
        ArrayList<Actor> actors = gamestage.getActorList();

        tg_angle = direction(actors);
        
        int turn = shortSide();

        if(actions[0]){
            gamestage.addActor(new Laser((int) this.getX(), (int) this.getY(), - Math.atan2(p_y - this.getY(), p_x - this.getX() + 90), gamestage));
            cooldown = 300;
        }
        if(actions[1]){
            turn*=-1;
        }
        if(actions[2]){
            cooldown --;
        }
	if(actions[3]){
            angle += turn;
            super.moveAngle();
	}
    }

    private double direction(ArrayList<Actor> actors){
        double dx = (actors.get(0).getX() - this.getX()), dy = (actors.get(0).getY() - this.getY());
        return -Math.toDegrees(Math.atan2(dy, dx)) + 90;
    }

    private int shortSide(){
        boolean inside;
        angle = (angle + 360) % 360;
        tg_angle = (tg_angle + 360) % 360
        inside = Math.abs(angle - tg_angle) < Math.min(angle, tg_angle) - Math.max(angle, tg_angle) + 360
        if(inside == (tg_angle > angle))
            return 1;
        return -1;
    }


    @Override
    protected void update() {
        this.aiPlan();
        this.aiAct();
    }
}

